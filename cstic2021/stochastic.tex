\documentclass[conference,letterpaper]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{natbib}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{subfigure}               %²åÈë²¢ÅÅÍŒÆ¬
\usepackage{CJK}                     %²åÈëÊýÑ§¹«Êœ
\usepackage{indentfirst}             %²åÈëÊýÑ§¹«Êœ
\usepackage{amsmath}                 %²åÈëÊýÑ§¹«Êœ
\usepackage{upgreek}                 %Æœ·œÎ¢Ã×µ¥Î»
\usepackage{tabu}                    %²åÈë±ížñ
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{arydshln}                %²åÈë±ížñ
\usepackage{makecell}                %ŒÓºÚÄ³žùÏß
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{float}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{tabularx}
\geometry{a4paper,left=2cm,right=2cm,top=2.5cm,bottom=4.6cm}
\renewcommand\refname{\textbf{\large REFERENCES}}
\setlength{\parindent}{0.63cm}
\setlength{\columnsep}{0.8cm}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}
    {-\baselineskip}{0.001\baselineskip}{\bf\leftline}}
\makeatletter
\renewcommand{\subsection}{\@startsection{subsection}{1}{0mm}
	{-\baselineskip}{0.001\baselineskip}{\bf\leftline}}
\makeatletter
\captionsetup[figure]{labelfont=it,textfont={it},name=Figure}
\captionsetup[table]{name={TABLE},labelsep=period}
%\usepackage[labelfont=it,textfont=it]{caption}
\begin{document}
\title{ \Large\textbf{ Stochastic Circuit Design Based on Exact Synthesis}\vspace{-1.2em} }
%\thanks{The work was supported by NSFC under Grant 61871242.}
\author{\IEEEauthorblockN{\textit{\large Xiang He, and Zhufei Chu$^*$}}
\IEEEauthorblockA{\large EECS, Ningbo University, Ningbo 315211, China \\ $^*$ Email: chuzhufei@nbu.edu.cn \vspace{-0.5em}}}

\maketitle
\section*{\textbf{\large ABSTRACT}}
Stochastic computing is an emerging paradigm that converts binary numbers into stochastic bitstreams to perform complex arithmetic computing using simple digital circuits. 
Stochastic computing is highly fault-tolerant and has been used in many applications. 
However, due to the large solution space of the problem, stochastic circuit synthesis is more complicated than the traditional logic synthesis.
Previous methods use a heuristic method to synthesize a stochastic circuit. In this paper, a novel exact synthesis method using Boolean satisfiability (SAT) is proposed to obtain an optimal stochastic circuit represented by majority-inverter graphs (MIGs), which is a dedicated homogeneous logic network. The experimental results show that the proposed approach can achieve 21\% area reduction, 4\% delay improvement, with 3\% mean absolute error trade-off.  
\vspace{2ex}

%\begin{IEEEkeywords}
%stochastic computing; exact synthesis; logic synthesis; majority
%\end{IEEEkeywords}

\section*{\textbf{\large INTRODUCTION}}
Modern circuit development is limited by many constraints, such as voltage variations, thermal, variations and soft errors. These physical phenomena are susceptible to errors, thus reliability has become an important issue. Stochastic computing has received increasing attention as an unconventional computing method for solving these problems. It is unique since it represents and processes information in the probabilistic form and is highly fault-tolerant for bit flips. Stochastic computing converts numbers $x\in[0,1]$ into stochastic bitstreams containing only 0 and 1. 
Each bit has probability $x$ of being a one and probability $1-x$ of being a zero in the bitstream. The numbers are represented by the probability of the one  in the bitstream. For example, (0,1,0,0), (0,0,0,1), and (0,0,1,0,1,0,0,0) are possible representations of 0.25. To obtain high precision, a number is usually represented by a long bitstream, where a few bits are flipped without large changes in value. By converting numbers into random bitstreams, stochastic computing transforms a complex computing unit into a simple circuit with gates. Thus many arithmetic operations can be implemented with very simple logic circuits. For example, multiplication in stochastic computing can be implemented with an AND gate if the two input stochastic bitstreams are independent, as shown in Figure ~\ref{fig:sto}.  
Stochastic computing has been applied in many applications~\cite{1} such as image processing, neural networks, decoding of low-density parity-check (LDPC) code, filter design.


\begin{figure}[t]
	\centering
	\includegraphics[width=3.3in]{fig/AND3.pdf}
	\caption{\label{fig:sto}AND gate performs multiplication by stochastic bitstreams.}  \vspace{-3.5ex}
\end{figure}

In stochastic computing, many different Boolean functions can be implemented to compute the same function, which has large solution space for the synthesis of stochastic circuits. To adapt stochastic computing to more functions, researchers have recently proposed several synthesis methods. One of the state-of-the-art methods is a heuristic breadth-first search algorithm~\cite{2}, which is based on assigning
cubes (i.e., product terms) to the on-set of the Boolean function. However, heuristics cannot find optimal solutions. Exact synthesis is a new approach, which is a problem of finding logical networks that represent given Boolean functions and respect given constraints. With exact synthesis, it is possible to find optimum networks, e.g., in size or depth. In this paper, we use exact synthesis method to obtain an optimal stochastic computing circuit represented by MIGs. The experimental results show that the exact synthesis approach achieves improvements in area and delay, compared with the heuristic approach.
\vspace{2ex}

\section*{\textbf{\large BACKGROUND}}
\subsection*{\textbf{Stochastic Computing Circuits }}
A general form of the stochastic circuit is shown in Figure ~\ref{fig2}, which is a combinational circuit. For a function of single variable $x$, the stochastic number generator (SNG) generates $n$ inputs $X_{1}, \ldots, X_{n}$, whose probability is $x$, where $n$ is the highest degree of the variable $x$ in the function. SNGs usually consist of a pseudo-random number generator and a comparator. In addition, the linear feedback shift register (LFSR) generates $m$ inputs $Y_{1}, \ldots, Y_{m}$ with probability 0.5. The stochastic bitstreams of these $n+m$ inputs are processed by a combination logic circuit.

\begin{figure}[t]
	\centering
	\includegraphics[width=3in]{fig/sc.pdf}	
	\caption{\label{fig2}A general form of stochastic computing circuits.} \vspace{-2ex}
\end{figure}

For $i\in[0,n]$, let $G(i)$ represents the number of minterms $(X_{1}, \ldots, X_{n}, Y_{1}, \ldots, Y_{m})$ that satisfying $F(X_{1}, \ldots, X_{n}, Y_{1}, \ldots, Y_{m})=1$ and $\sum_{j=1}^{n} X_{j}=i$. $(G(0), \ldots, G(n))$ is recorded as the problem vector~\cite{2}. For example, (0, 3, 2) is a problem vector using the truth table shown in Table~\ref{tab:tt} with $n=2$ and $m=2$. Its output probability realizes the function
\begin{equation}
f(x)=\frac{3}{4} x(1-x)+\frac{2}{4} x^{2}.\vspace{-2ex}
\end{equation}


\begin{table}[htbp]
\setlength{\abovecaptionskip}{0.cm}
\setlength{\belowcaptionskip}{0.pt}
\setlength{\tabcolsep}{1mm}
\caption{The Truth Table of a Boolean Function With Problem Vector (0, 3, 2).}
\centering \label{tab:tt}
\begin{tabular}{|c|c|c|c|c|}
\hline $\mathrm{Y}_{1} \mathrm{Y}_{2} \backslash \mathrm{X}_{1} \mathrm{X}_{2}$ & 00 & 01 & 11 & 10 \\
\hline 00 & & 1 & 1 & 1 \\
\hline 01 & & 1 & 1 & \\
\hline 11 & & & & \\
\hline 10 & & & & \\
\hline
\end{tabular}
\end{table}

The Boolean function shown in Table~\ref{tab:tt} is represented in a simplified sum-of-product (SOP) form
\begin{equation}
F=X_{2}\bar{Y_{1}}+X_{1} \bar{Y_{1}}\bar{Y_{2}}.
\end{equation}

In this way, the problem vector can form a logical circuit for stochastic computing, but there are many kinds of Boolean functions to implement the same problem vector. Table~\ref{tab:tt} shows just one of the 356 Boolean functions of the problem vector (0, 3, 2).

\subsection*{\textbf{Sat-based Exact Synthesis}}


Exact synthesis is the problem of finding optimal logic networks by giving a set of primitives. 
It is well known that the optimal size of a normal network is found via the SAT formula~\cite{3}. Based on the Knuth algorithm ~\cite{4}, the encoding method using majority-of-three operations is proposed~\cite{6}. 

1) Variables: For $1 \leq h \leq m$, $n<i \leq n+r$, and $0<t<2^{n}$, the variables used in the SAT formulation are defined in the following:
\begin{equation}
\begin{aligned}
&x_{i t}: \quad t^{\mathrm{th}} \text { bit of } x_{i} \text { 's truth table }\\
&\begin{aligned}
g_{h i}: &\left[g_{h}=x_{i}\right] \\
s_{i j k}: &\left[x_{i}=x_{j} \circ_{i} x_{k}\right] \text { for } 1 \leq j<k<i \\
f_{i p q}: & \circ_{i}(p, q) \text { for } 0 \leq p, q \leq 1, p+q>0
\end{aligned}
\end{aligned}
\end{equation}

If function $g_{h}$ is represented by gate $x_{i}$, variable $g_{h i}$ is true. The select variables $s_{i j k}$ is true if the inputs of gate $x_{i}$ are $x_{j}$ and $x_{k}$. The variable $f_{i p q}$ is true, if the operation of gate $x_{i}$ is true for the input assignment (p, q).

2) Clauses: Intuitively, if the gate $x_{i}$ must operate as $b \circ_{i} c=a$.  The main clauses to represent the operation constraints can be written as conjunction normal forms (CNFs), that is
\begin{equation}
\left.\left(\bar{s}_{i j k} \vee\left(x_{i t} \oplus a\right) \vee\left(x_{j t} \oplus b\right) \vee\left(x_{k t} \oplus c\right)\right) \vee\left(f_{i b c} \oplus \bar{a}\right)\right)
\end{equation}
Let $\left(t_{1}, \ldots, t_{n}\right)_{2}$ be the binary encoding of $t$, then the clauses
\begin{equation}
\left(\bar{g}_{h i} \vee\left(\bar{x}_{i t} \oplus g_{h}\left(t_{1}, \ldots, t_{n}\right)\right)\right)
\end{equation}
constrain the output values to the gates they point to. Moreover, additional constraints can help to reduce the search space for the SAT solver~\cite{4}.

\section*{\textbf{\large PROPOSED DESIGNS}}

In this section, we will demonstrate the optimized design of stochastic circuit based on exact synthesis which can find optimal logic networks by giving a set of primitives.
\subsection*{\textbf{Encoding }}
MIGs are used as underlying logic primitives for the synthesis of Boolean functions and containing AND/OR-inverter graphs. The variables to encode the truth table and the output gate are the same with Knuth’s method. 
%%%%%%%%%%
But the ${s}_{i j k}$ and $f_{i p q}$ need to be reexamined. In MIGs networks, each node has 3 children. The select variables ${s}_{i j k l}$ is true if the operands of gate $x_{i}$ are $x_{j}$, $x_{k}$, and $x_{l}$.  The
variable $f_{i p q u}$ is true if the operation of gate $x_{i}$ is true for the input assignment (p, q, u).

We use symbolic encoding method to represent all 8 3-input Majority Gates. The operation variable for step $r$ is encoded as $O_{r 1},...,O_{r 8}$, we need add additional  clauses to make the algorithm work.
%%%%%%%%%%



Note that the traditional exact synthesis makes use of fixed truth table as input, the output is the optimal logic representations in size or depth.
In this paper, since the stochastic circuit has problem vector, we add cardinality clauses to constraint the on-sets of logic function. In this way, the SAT solver can answer whether we can realize a stochastic problem vector using giving primitives. 

For example, we know that $G(2) = 2$ according to the problem vector (0, 3, 2) in Table~\ref{tab:tt}. We restrict the sum of all minterms under columns ``01'' and ``10'' to be equal to $G(2)$. 
Let $f_{Y_1Y_2X_1X_2}$ be a minterm, then all minterms under columns ``11''
are $f_{0011}$, $f_{0111}$, $f_{1011}$, and $f_{0011}$.
Thus the cardinality constraint is \vspace{-0.5ex}
\begin{equation}
f_{0011} + f_{0111} + f_{1011} + f_{0011} = 2.
\end{equation}
Note that this constraint should be transformed into CNFs which are feasible for SAT solving.

Due to the encoder works for normal function, we should also try the unnormal function, just redefine the problem vector, if $m = 1$, $n = 2$, the problem vector is $(1,3,2)$, then the inveterd problem vector is $(2-1=1, 4-3=1, 2-2=0)$.


%Given three Boolean variables, $a$, $b$, and $c$, each gate can realize $\langle abc\rangle$, $<\bar{a} b c>$, $<a \bar{b} c>$ or $<a b \bar{c}>$. By setting any variable to constant 0 or 1, one can behave as AND or OR, respectively. $a b$, $\bar{a} b$, $a \bar{b}$, and $a+b$ should also be considered. The defined variables~\cite{5} are constrained by a set of clauses. For each gate $r$, the operation variable  $o_{r w}$ is true if the operation of gate $r$ is $w$, where $w$ is one of the 8 possible normal majority operations.

%For example, suppose the selection variable $S_{i a b c}$, and the input combination is (100), then we can check $o_{r 1}=<abc>$ outputs 0, while $o_{r 8}=a+b$ outputs 1. Thus the clause is added as follows.
%%$$ \bar{S}_{i a b c} \vee \bar{x}_{i t} \vee o_{r 3} \vee o_{r 4} \vee o_{r 7} \vee o_{r 8}$$
%%$$ \bar{S}_{\text {iabc}} \vee \bar{x}_{i t} \vee \bar{o}_{r 1}$$
%%$$\bar{S}_{i a b c} \vee \bar{x}_{i t} \vee \bar{o}_{r 6}$$
%%$$\bar{S}_{\text {iabc}} \vee x_{i t} \operatorname{Vo}_{r 1} \operatorname{Vo}_{r 2} \operatorname{Vo}_{r 5} \operatorname{Vo}_{r 6}$$
%%$$\bar{S}_{i a b c} \vee x_{i t} \vee \bar{o}_{r 3}$$
%%$$\bar{S}_{i a b c} \vee x_{i t} \vee \bar{o}_{r 8}$$
%\begin{equation}                     %equations of AU and CU
%\begin{split}
%&\bar{S}_{i a b c} \vee \bar{x}_{i t} \vee o_{r 3} \vee o_{r 4} \vee o_{r 7} \vee o_{r 8} \\
%&\bar{S}_{\text {iabc}} \vee \bar{x}_{i t} \vee \bar{o}_{r 1} \\
%\centering &\ldots \\
%&\bar{S}_{\text {iabc}} \vee x_{i t} \vee {o}_{r 1} \vee{o}_{r 2} \vee{o}_{r 5} \vee{o}_{r 6}\\
%&\bar{S}_{i a b c} \vee x_{i t} \vee \bar{o}_{r 3}\\
%\centering &\ldots \\
%&\bar{S}_{i a b c} \vee x_{i t} \vee \bar{o}_{r 8}\\
%\end{split}
%\end{equation}
%
%Further, clause $\bigvee_{w=1}^{8} o_{r w}$ ensure that each step should realize at least one of the 8 operations.
\subsection*{\textbf{Algorithms }}
Based on the encoding methods described above, given a problem vector, our algorithm can find a solution to satisfy both problem vector cardinality constraints and given logical primitives. The initial number of gates is set as 0. If a solution is found, it returns a MIG; otherwise, the algorithm will increase the number of gates, then restart encoding and solve until the upper limit is reached. This will ensure that the algorithm can find the MIGs network with the optimal number of gates.

\section*{\textbf{\large EXPERIMENTAL RESULT}}
In this section, we apply our exact synthesis method to synthesize several common arithmetic functions by our open-source logic synthesis tool ALSO\footnote{https://github.com/nbulsi/also} using the command `\texttt{stochastic}', such as trigonometric, exponential, and logarithmic functions. The method in~\cite{2} is used to compare with our method. It is a state-of-the-art method in synthesizing these commonly used functions, using a heuristic breadth-first search algorithm. 

Table~\ref{tab2} shows the comparison results between the method in~\cite{2} and ours. For a fair comparison, the two methods use the same precision $m$ and degree of functions $n$, respectively. For each function $f(x)$, we chose nineteen input points $x=0.05, 0.1,..., 0.95$ for simulation. We chose the length of the stochastic bitstreams as 10240. We also evaluate the mean absolute error (MAE) and area-delay product(ADP). 
The results of area and delay are reported by ABC\footnote{https://github.com/berkeley-abc/abc}.

Generally, the result shows that the two methods have almost the same accuracy. But we can achieve 21\% reduction in area, and 4\% improvement in delay. In terms of ADP, our method has 23\% reduction on average.
The MAE is slightly increased as a trade-off, which is affordable.
%The results of simulation show that our approach produces better circuits in terms of area and delay.

\begin{table}[htbp]
\setlength{\abovecaptionskip}{0.cm}
\setlength{\belowcaptionskip}{0.pt}
\setlength{\tabcolsep}{0.58mm}
\caption{Comparisons of some arithmetic functions.}
\centering \label{tab2}
\begin{tabularx}{\linewidth}{Xrrrrrrrrrr}
\toprule 
\multirow{2}{*} {Functions}   &\multirow{2}{*} {m} &\multirow{2}{*}{n} & \multicolumn{4}{c}{Method in~\cite{2}}   & \multicolumn{4}{c}{Our Method}\\
\cmidrule(lr){4-7}\cmidrule(lr){8-11}
 & & &\thead[c]{Area} &\thead[c]{Delay} &\thead[c]{ADP} &\thead[c]{MAE} &\thead[c]{Area} &\thead[c]{Delay} &\thead[c]{ADP} &\thead[c]{MAE}\\
\midrule
$\sin (x)$ &2  &4 &15 &4.5 &67.5 &0.0221  &11 &3 &33 &0.0364\\
$\cos (x)$ &3 &3 &3 &1.1 &3.3 &0.0080 &3 &1.1 &3.3 &0.0079  \\
$\tanh (x)$ &3 &2 &14 &3.3 &46.2 &0.0074 &7 &3 &21 &0.0075 \\
$\log_{2}(1+x)$ &5 &2 &16 &3.4 &54.4 &0.1810 &14 &4.5 &63 &0.1809 \\
$e^{-x}$ &3 &2 &8 &3.1 &24.8 &0.0084 &8 &3.1 &24.8 &0.0082\\
$sin(\pi x)$ &5 &2 &12 &3.1 &37.2 &0.1829 &11 &3.1 &34.1 &0.1830\\
\midrule
\multicolumn{3}{c}{Average} & 1 & 1 & 1 & 1 & 0.79 & 0.96 & 0.77 & 1.03 \\
\bottomrule

\end{tabularx}
\label{bs}
\end{table}



\section*{\textbf{\large SUMMARY}}
In this paper, we proposed a method based on  exact synthesis to synthesize general stochastic circuits. In stochastic computing, many different Boolean functions can implement the same function computation, which brings great design space for synthesis of stochastic circuits. Comparing with traditional heuristic approaches, our exact synthesis algorithm can easily solve complex constraint problems, and apply MIGs to implement function computation in stochastic circuits. The algorithm considers all different constraints and demonstrates that classical heuristic logic synthesis tools may lead to solutions that do not satisfy all requirements. The experimental results show that the proposed approach can achieve 21\% area reduction, 4\% delay improvement, with 3\% mean absolute error trade-off.\vspace{-3ex}

In this paper, small circuits and functions of a single variable are considered, and future work will focus on the study of larger circuits and functions of multiple variables.



\section*{\textbf{\large ACKNOWLEDGEMENT}} \vspace{-3ex}
The work was supported by NSFC under Grant 61871242.

\small
\begin{thebibliography}{10}
\bibitem{1}A. Alaghi, W. Qian and J. P. Hayes, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 37, no. 8, pp. 1515-1531, 2018.
\bibitem{2}X. Peng and W. Qian, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 37, no. 12, pp. 3109-3122, 2018.
\bibitem{3}Z. Chu, W. Haaswijk, M. Soeken, Y. Xia, L. Wang and G. De Micheli, 2019 IEEE International Symposium on Circuits and Systems, pp. 1-5,  2019.
\bibitem{4}D. E. Knuth, Volume 4,Fascicle 6: Satisfiability. Addison-Wesley Professional, 2015.
\bibitem{5}E. Testa, M. Soeken, O. Zografos, F. Catthoor, and G. De Micheli,  International Workshop on Logic and Synthesis (IWLS), pp. 21–27, 2017.
\bibitem{6}M. Soeken, L. G. Amarù, P. Gaillardon and G. De Micheli, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 36, no. 11, pp. 1842-1855, Nov. 2017.
\end{thebibliography}
\bibliographystyle{unsrt}
\enlargethispage{-6.5cm}
%\bibliography{refs}
\end{document}

\begin{tabular}{cccccccc}
\hline Function & Degree & & Area & Delay & Area-delay product & Product ratio & MAE \\
\hline \multirow{2}{*} {$\sin (x)$} & \multirow{2}{*} {7} & Cube Factor & 43 & 6.7 & 288.1 & \multirow{2}{*} {0.686} & 0.0106 \\
& & & 56 & 7.5 & 420.0 & & 0.0107 \\
\hline \multirow{2}{*} {$\cos (x)$} & \multirow{2}{*} {8} & Cube & 27 & 4.7 & 126.9 & \multirow{2}{*} {0.332} & 0.0075 \\
& & Factor & 58 & 6.6 & 382.8 & & 0.0079 \\
\hline \multirow{2}{*} {$\tanh (x)$} & \multirow{2}{*} {9} & Cube & 74 & 6.4 & 473.6 & \multirow{2}{*} {0.992} & 0.0115 \\
& & Factor & 62 & 7.7 & 477.4 & & 0.0113 \\
\hline \multirow{2}{*} {$\log (1+x)$} & \multirow{2}{*} {5} & Cube & 49 & 6.3 & 308.7 & \multirow{2}{*} {0.757} & 0.0172 \\
& & Factor & 48 & 8.5 & 408.0 & & 0.0173 \\
\hline \multirow{2}{*} {$e^{-x}$} & \multirow{2}{*} {5} & Cube & 67 & 6.6 & 422.2 & \multirow{2}{*} {1.082} & 0.0109 \\
& & Factor & 47 & 8.3 & 390.1 & & 0.0104 \\
\hline \multirow{2}{*} {$\sin (\pi x)$} & \multirow{2}{*} {9} & Cube & 76 & 6.6 & 501.6 & \multirow{2}{*} {1.484} & 0.0312 \\
& & Factor & 52 & 6.5 & 338.0 & & & 0.0318 \\
\hline
\end{tabular}
